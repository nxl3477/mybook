# 函数式编程

## 范畴论
苦涩难懂， 并没有完全理解，我的理解： 
态射： 只要两者之间存在某种关系， 就可以进行态射。

笔记: 
1. 函数式编程时范畴论的数学分支是一门很复杂的数学， 认为世界上所有概念体系都可以抽象出一个个范畴

2. 彼此之间存在某种关系概念、 事物、对象等等，  都构成范畴。 任何事物只要找出他们之间的关系， 就能定义

3. 箭头表示范畴成员之间的关系， 正式的名称叫做“态射”(morphism)。范畴论认为， 同一个范畴的所有成员， 就是不同状态的“变形”(transformation)。通过“态射”， 一个成员可以变形成另一个成员。

## 函数式编程的基础理论
用数学的思维去驱动编程
函数式编程中没有`if else`、没有 `switch`
1. 函数式编程 ( Functional Programming) 其实相对于计算机的历史而言是一个非常古老的概念， 甚至早于第一台计算机的诞生。 函数式编程的基础模型来源于 `入(Lambda x => x*2)` 演算， 而 `入` 演算并非设计于在计算机上执行， 它是在 20 世纪三十年代引入的一套用于研究函数定义、函数应用和递归的形式系统。

2. 函数式编程不是用函数来编程， 也不是传统的面向过程编程。 主旨在于将复杂的函数符合成简单的函数（计算理论， 或者递归论， 或者兰姆达演算） 。 运算过程尽量携程一系列嵌套的函数调用。

3. Javascript是披着C外衣的Lisp; Lisp是一门纯函数式编程的语言。 但是 JS原本设计值初并没有考虑面向对象， 面向对象是后来应需求加入的， 慢慢的就朝着面向对象走了。

4. 真正的火热是随着React的高阶函数而逐步升温。


## 函数式基本
1. 函数是一等公民。所谓”第一等公民”（first class），指的是函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。

2. 不可改变量。在函数式编程中，我们通常理解的变量在函数式编程中也被函数代替了：在函数式编程中变量仅仅代表某个表达式。这里所说的’变量’是不能被修改的。所有的变量只能被赋一次
初值

3. map & reduce他们是最常用的函数式编程的方法。

1.  函数是”第一等公民”
2. 只用”表达式"，不用"语句"
3. 没有”副作用"
4. 不修改状态
5. 引用透明（函数运行只靠参数）

## 专业术语

* 纯函数
* 函数柯里化
* 函数组合
* point Free
* 声明式与命令式代码
* 惰性求值


### 纯函数
对于相同的输入， 永远会得到相同的输出， 而且没有任何可观察的副作用， 也不依赖外部环境的状态。

如果函数返回结果有一定的随机成分那就不算是纯函数

**优点**
可缓存性: 因为纯函数的返回结果根据传入的值是永远一致的， 所以我们可以存储保存结果 ，只需要一次计算， 第二次直接就可以返回， 比如`lodash`的中`_.memorize`方法



### 非纯改为纯
利用函数柯里化， 将一部分固定不变的参数锁住，让有随机性的值或参数放在第二次调用时传入， 以达到类似纯函数的目的


## 函数柯里化
柯里化是一种“预加载”函数的方法，通过传递较少的参数，
得到一个已经记住了这些参数的新函数，某种意义上讲，这是一种
对参数的“缓存”，是一种非常高效的编写函数的方法


## 函数组合
使用纯函数和柯里化会经常写成洋葱圈的样子`f(g(a(x)))` 类似这样。
为了避免函数的重复嵌套, 我们需要使用`函数组合`的方式

就是类似于搭积木， 提供一个拼接函数， 构建好组合的模式， 然后根据用户传入参数
```
function composer(a, b) {
  return a(b())
}
// 自由传入你的函数， 可以调换顺序， 拼接模式已被预设
console.log(composer((x) => 3 + x, ()=> 1))
```

使用函数组合会使代码更灵活
这就涉及到数学中的组合问题
![](md_imgs/composer.png)



## Point Free
> 本笔记观看阮一峰教程后实践编写

> Pointfree 就是如何使用函数式编程的答案 --- 阮一峰

我们可以把数据处理的过程，定义成一种与参数无关的合成运算。不需要用到代表数据的那个参数，只要把一些简单的运算步骤合成在一起即可。

Pointfree 的本质就是使用一些通用的函数，组合出各种复杂运算。上层运算不要直接操作数据，而是通过底层函数去处理。这就要求，将一些常用的操作封装成函数。


### 函数的拆分与合成
程序的运行过程无非就是 输入a 返回 b， 但在a 变为b的过程中， 我们可以细分， 比如 `a -> m -> n -> b` ,这样中间多了两个中间过渡值`m`和 `n`, 

就像一根水管， 传入的a 流向了 b端

![](md_imgs/hose.png)

拆分成三根水管， a 要经过水管 f1 得到 m 然后传入函数f2 得到 n ,最后通过水管f3得到 b

![](md_imgs/3hose.png)

细分了过程， 但结果相同，并且使得过程可替换了， 这个水管不好用了可以立马换其他的， 而不是整根替换， 过程可控了

让我们来看一个简单的例子， 

在一段字符串中找出最长的字符长度
首先， 我们定义一个pipe 函数， 把它接收的参数想象成一段一段的水管, 他负责按顺序拼接你传的"水管"， 将上一个`水管`返回的值, 

顺便说一下这个pipe用了尾递归

```
// 将上一次的计算结果传给下一个函数
function pipe(...args) {
  const argsCopy = [...args]
  return function (str) {
    return (function loop(val) {
      if( argsCopy.length == 0 ) {
        return val
      }
      const result = argsCopy.shift()(val)
      return loop(result)
    })(str);
  }
}
```

秉承着函数的单一职责， 我们编写了许多个“水管”， 分别处理不同的步骤

```
// 找出这段字符串最长的单词
var words = "aa bb cc ccccc"

// map 
const arrMap = (arr, callback) => Array.prototype.map.call(arr, callback)

// 根据空格分割成数组
const splitBySpace = str => str.split(' ')

// 获取字符长度
const getLen = str => str.length

// 字符串转长度
const str2length = arr => arrMap(arr, getLen)

// 逆序排序
const sortByDesc = arr => [].sort.call(arr, (a, b) => b - a)

// 获取数组第一个
const getArrFirst = (arr) => arr[0]
```

然后我们按部就班的排好顺序，传入pipe 

整理下思路
字符串转为数组 -> 将数组中的单词转为长度 -> 根据字符长度逆序排序 -> 然后获取第一个也就是最大的值

```
console.log( 
  pipe(
    // 根据空格分割
    splitBySpace, 
    // 将数组中的单词转为长度
    str2length, 
    // 根据字符长度逆序排序
    sortByDesc,
    // 获取第一个也就是最大的值
    getArrFirst

    // 传入字符
  )(words)
)

```




## 声明式与命令式代码
命令式代码的意思就是，我们通过编写一条又一条指令去让计算机执行一些动作，这其中一般都会涉及到很多繁杂的细节。而声明式就要优雅很多了，我们通过写表达式的方式来声明我们想干什么，而不是通过一步一步的指示。

```
//命令式
let CEOs = [];
for(var i = 0; i < companies.length; i++)
CEOs.push(companies[i].CEO)
}
//声明式
let CEOs = companies.map(c => c.CEO);
```

## 函数式编程的优缺点

**优点**
函数式编程的一个明显的好处就是这种声明式的代码，对于无副作用的纯函数，我们完全可以不考虑函数内部是如何实现的，专注于编写业务代码。优化代码时，目光只需要集中在这些稳定坚固的函数内部即可。

**缺点**
相反，不纯的函数式的代码会产生副作用或者依赖外部系统环境，使用它们的时候总是要考虑这些不干净的副作用。在复杂的系统中，这对于程序员的心智来说是极大的负担。



## 惰性求值、惰性函数、惰性链
惰性其实就是延迟的一次， 让函数在当他用到的时候再去执行， 

惰性函数呢一般用在规避重复的浏览器能力检测， 因为这个特性只需要排查一次就知道结果了， 重复的去排查性能未免太差

惰性链的大致实现就是，先暂时存储方法， 不去执行， 等到调用执行方法时再统一执行



## 偏函数和偏应用函数
偏函数通熟易懂的讲就是单个参数的函数

为什么叫偏 ， 因为一个函数只能处理一个逻辑， 比如 Bind

> 偏函数用法是指创建一个 调用另一个部分——参数或变量已经预置的的函数 的函数的用法


一个函数通过预先填充原始的部分创建一个新函数

柯里化就是偏函数的一个应用



## 函数式编程专业术语
* 高阶函数
* 尾调用优化
* 闭包
* 容器、Functor
* 错误处理、Either、AP
* IO
* Monad


## 高阶函数
* 它是一等公民
* 它已一个函数作为参数
* 已一个函数作为返回结果

高阶函数就是对已封装的函数再进行一次封装， 然后返回这个函数， 达到更高程度的抽象


## 爆栈和死循环的区别
**死循环**
是持续性的占用线程， 导致线程饥渴， 线程无力去执行其他的事件， 导致浏览器失去交互能力和响应， 相当于一口气吃了个咽不下的大面包， 你无力再去吃其他的了

无法再执行更多的Js

**爆栈**
有进有出， 类似于吃的过撑了， 但是它会吐出来，爆栈是存留过多导致的 ， 每个函数都很小， 但慢慢的越变越大会把你撑死, 浏览器依旧可交互
```
function foo() {
    foo() 
}
foo()
```
**爆栈依旧能调用点击事件**
![](md_imgs/recur1.png)





## 尾调用优化
**浏览器实现**
浏览器暂未很好的实现， 原本草案浏览器自身实现的优化， 只需要在你函数名前面加上`#`号即可, 如`#function() {}` 这样， 浏览器会将你的递归代码变成循环， 只保留最后一个执行栈， 但是不利于调试， 如果你使用`try catch` 去捕获异常只能拿到最后的一个错误信息， 估计也就是这样草案被驳回了

**这是浏览器实现原理**
> 在ECMAScript 6，我们将迎来尾递归优化，通过尾递归优化，javascript代码在解释成机器码的时候，将会向while看起，也就是说，同时拥有数学表达能力和while的效能。


**自己实现**
在函数的末尾调用另一个函数， 然后将当前的值传给该函数， 再经由该函数调用自身， 继续计算结果， 来回的切换函数以达到类似循环的效果， 防止栈溢出

```
function foo(x, sum) {
    if(x == 1) {
        return sum 
    }
    return foo2(--x, sum + x) 
}
function foo2(...args) {
    return foo(...args)
}
console.log(foo(1000, 0)) // 499500
```



## 递归和尾递归

**递归**   
普通递归时，内存需要记录调用的堆栈所出的深度和位置信息。在最底层计算返回值，再根据记录的信息，跳回上一层级计算，然后再跳回更高一层，依次运行，直到最外层的调用函数。在cpu计算和内存会消耗很多，而且当深度过大时，会出现堆栈溢出

因为递归会导致`ESC stack` 创建新的函数执行栈，大量保存栈的记录，就会导致栈的溢出， 就好像你一直吃零食把自己吃撑死了

**尾递归** 

函数尾调用自身， 也就是在所有其他操作都执行完才调用自身，叫做尾递归， 因为函数执行会有监测, 当一个函数以后都没有用的时候就把他出栈了， 所以就只保留一个函数的执行栈了。


整个计算过程是线性的，调用一次`sum(x, total)`后，会进入下一个栈，相关的数据信息和跟随进入，不再放在堆栈上保存。当计算完最后的值之后，直接返回到最上层的



这是一个的尾递归demo， 在foo的最底部调用了自身， 在调用自身前，当前函数已全部执行完毕， 包括 `--x`和`sum+x` ， 

```
function foo(x, sum) {
    if(x == 1) {
        return sum 
    }
    return foo(--x, sum + x) 
}
console.log(foo(1000, 0)) // 499500
```





### ECS的含义
　  一系列活动的执行上下文从逻辑上形成一个栈。栈底总是全局上下文，栈顶是当前（活动的）执行上下文。当在不同的执行上下文间切换（退出的而进入新的执行上下文）的时候，栈会被修改（通过压栈或者退栈的形式）。
* 压栈：全局EC-->局部EC1-->局部EC2-->当前EC 
* 出栈：全局EC<--局部EC1<--局部EC2<--当前EC



## 函数式编程库
* RxJs[frp]
* cycleJs
* lodashJS、 lazy(惰性求值)
* underscoreJS
* ramdajs


## Rxjs
响应式编程是继承自函数式编程，声明式的，不可变的，没有副作用的是函数式编程的三大护法。其中不可变武功最高深。一直使用面向对象
范式编程的我们，习惯了用变量存储和追踪程序的状态。RxJS从函数式编程范式中借鉴了很多东西，比如链式函数调用，惰性求值等等。
在函数中与函数作用域之外的一切事物有交互的就产生了副作用。比如读写文件，在控制台打印语句，修改页面元素的css等等。在RxJS中，把副作用问题推给了订阅者来解决。


## Cycle.js
Cycle.js 是一个基于 Rxjs 的框架，它是一个彻彻底底的 FRP 理念的框架，和 React 一样支持 virtual DOM、JSX 语法，但现在似乎还没有看到大型的应用经验。

本质的讲，它就是在 Rxjs 的基础上加入了对 virtual DOM、容器和组件的支持


## Underscore.js
Underscore 是一个 JavaScript 工具库，它提供了一整套函数式编程的实用功能，但是没有扩展任何 JavaScript 内置对象。 他解决了这个问题：“如果我面对一个空白的 HTML 页面，并希望立即开始工作，我需要什么？” 他弥补了 jQuery 没有实现的功能，同时又是 Backbone 必不可少的部分。

Underscore 提供了100多个函数，包括常用的：map、filter、invoke— 当然还有更多专业的辅助函数，如：函数绑定、JavaScript 模板功能、创建快速索引、强类型相等测试等等。



## RamdaJs
lodash是一个具有一致接口、模块化、高性能等特性的JavaScript工具库，是underscore.js的fork，其最初目标也是“一致的跨浏览器行为。。。，并改善性能”。

lodash采用延迟计算，意味着我们的链式方法在显式或者隐式的value()调用之前是不会执行的，因此lodash可以进行shortcut（捷径） fusion（融合）这样的优化，通过合并链式大大降低迭代的次数，从而大大提升其执行性能。

就如同jQuery在全部函数前加全局的$一样，lodash使用全局的_来提供对工具的快速访问。