

# 递归和尾递归

**递归**   

普通递归时，内存需要记录调用的堆栈所出的深度和位置信息。在最底层计算返回值，再根据记录的信息，跳回上一层级计算，然后再跳回更高一层，依次运行，直到最外层的调用函数。在cpu计算和内存会消耗很多，而且当深度过大时，会出现堆栈溢出

因为递归会导致`ESC stack` 创建新的函数执行栈，大量保存栈的记录，就会导致栈的溢出， 就好像你一直吃零食把自己吃撑死了

**尾递归** 

函数尾调用自身， 也就是在所有其他操作都执行完才调用自身，叫做尾递归， 因为函数执行会有监测, 当一个函数以后都没有用的时候就把他出栈了， 所以就只保留一个函数的执行栈了。


整个计算过程是线性的，调用一次`sum(x, total)`后，会进入下一个栈，相关的数据信息和跟随进入，不再放在堆栈上保存。当计算完最后的值之后，直接返回到最上层的



这是一个的尾递归demo， 在foo的最底部调用了自身， 在调用自身前，当前函数已全部执行完毕， 包括 `--x`和`sum+x` ， 

```
function foo(x, sum) {
    if(x == 1) {
        return sum 
    }
    return foo(--x, sum + x) 
}
console.log(foo(1000, 0)) // 499500
```


## 爆栈和死循环的区别
**死循环**

是持续性的占用线程， 导致线程饥渴， 线程无力去执行其他的事件， 导致浏览器失去交互能力和响应， 相当于一口气吃了个咽不下的大面包， 你无力再去吃其他的了

无法再执行更多的Js

**爆栈**

有进有出， 类似于吃的过撑了， 但是它会吐出来，爆栈是存留过多导致的 ， 每个函数都很小， 但慢慢的越变越大会把你撑死, 浏览器依旧可交互
```
function foo() {
    foo() 
}
foo()
```
**爆栈依旧能调用点击事件**
![](md_imgs/recur1.png)




## 尾调用优化
**浏览器实现**
浏览器暂未很好的实现， 原本草案浏览器自身实现的优化， 只需要在你函数名前面加上`#`号即可, 如`#function() {}` 这样， 浏览器会将你的递归代码变成循环， 只保留最后一个执行栈， 但是不利于调试， 如果你使用`try catch` 去捕获异常只能拿到最后的一个错误信息， 估计也就是这样草案被驳回了

**这是浏览器实现原理**
> 在ECMAScript 6，我们将迎来尾递归优化，通过尾递归优化，javascript代码在解释成机器码的时候，将会向while看起，也就是说，同时拥有数学表达能力和while的效能。


**自己实现**
在函数的末尾调用另一个函数， 然后将当前的值传给该函数， 再经由该函数调用自身， 继续计算结果， 来回的切换函数以达到类似循环的效果， 防止栈溢出

```
function foo(x, sum) {
    if(x == 1) {
        return sum 
    }
    return foo2(--x, sum + x) 
}
function foo2(...args) {
    return foo(...args)
}
console.log(foo(1000, 0)) // 499500
```

### ECS的含义
　  一系列活动的执行上下文从逻辑上形成一个栈。栈底总是全局上下文，栈顶是当前（活动的）执行上下文。当在不同的执行上下文间切换（退出的而进入新的执行上下文）的时候，栈会被修改（通过压栈或者退栈的形式）。
* 压栈：全局EC-->局部EC1-->局部EC2-->当前EC 
* 出栈：全局EC<--局部EC1<--局部EC2<--当前EC
