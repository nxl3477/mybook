# 前后端分离与用户验证

## 分离前
分离前我们所有功能都做成了一驼， 同在一台机器上

结构如:
* ui
* 业务逻辑
* 持久层

用户的请求从 Ui层逐层传至持久层， 持久层再去访问DB， 业务逻辑层做权鉴的认证

依靠给前端的cookie 中存储session_id 来保持会话

此时session存储在内存中， 并且内存中的数据也会做持久化（也是存储于数据库里）

持久化一般服务器会自动去做， 比如 java的tomcat

这是为了保证服务器重启不会把超时用户踢下线

## 分离后

前后端分离后， 我们就不再是和以前一样一坨了， 而是跑在不同的应用上面

并且现在的架构往往是支持多端的， 比如 mobile, pc ,native等

架构如下(从上至下， 实际情况可能还要跨层):

* pc、mobile、App
* 认证( 每个端都需要认证 )
* 反向代理
* 不同端的服务模块层
  * ----上下两层通过业务接口交互----
* 业务逻辑层
  * ----上下两层通过业务接口交互----
* 基础接口层（和业务无关的服务， 比如专门写表的， 专门拿资源的）
* 基本服务层(持久层、 缓存、服务器硬件等等)


现在前后端分离了， 那用户登录就是问题了， 不同端的登录信息如何共享




**在各端的用户登录之后， 将登录信息传至业务层的统一权鉴中心**

登录成功后， web 通过cookie存储用户信息 ， native 通过token存储信息
>  只要native 不进行root , 应用直接就无法互相访问私有数据库SQLiet， 如果你进行了root， 那各个应用就有权力向你提权， 获取更大的操作权限， 甚至可以达到系统级的操作

这里王老师说了一个小知识， 在很久以前的诺基亚手机， 不支持cookie , 所以无法使用cookie去存储用户信息， 我们可以在登录成功后重定向， 然后再url上存储token

当业务规模比较大的情况下，比如有日志服务, 邮件服务，前端等等， 都需要权鉴， 那权鉴的方法就又多种处理方案了， 

1. 统一一处的权鉴中心，这样做实现最简单， 但访问量大的情况下此处可能成为瓶颈
2. 各个服务都建立权鉴中心， 解耦各个模块， 各个权鉴中心之间做会话共享


### 会话共享
每一个模块都有自己的权鉴系统，我们该如何做会话共享呢

我们可以把session存储在统一的一个数据库中， 为了提高效率， 采用 nosql数据库, 如： Redis

但是共享会话还涉及到一个问题， 每个语言的session 机制不同， 

1. java会把session序列化
2. php或Node可能回是一个简单的文本结构， 用Json做封装

为了能够多个子系统， 不同的语言能共同使用session ,需要设计出一个通用的session结构 ， 在每个存储接口时做一次格式的转换



## HTTP 专有Cookie

cookie在何处产生
> 服务端

谁可以修改cookie
> 服务端和客户端都可以



http only
> 只能由浏览器主动发起的请求， js 无法操作， 保证敏感数据的安全性